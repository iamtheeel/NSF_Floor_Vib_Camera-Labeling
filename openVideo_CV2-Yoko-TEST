
####
# Yoko Lu
# SFSU STARS Summer 2025
# Dr J Lab
###
# Opens a video file in OpenCV and shows frame processing timing
# Adds Pan, Tilt, Zoom estimation using feature tracking (ORB)
####

import time
import cv2
import numpy as np

# === SETTINGS ===
dir = '/Volumes/MY PASSPORT/Stars_day1Data/'
file = 's2_B8A44FC4B25F_6-3-2025_4-00-20 PM.asf'
filename = f"{dir}{file}"

# === Compare FPS (placeholder values for now) ===
def compare_video_fps(video1_fps, video2_fps):
    print(f"Video 1 FPS: {video1_fps} Hz")
    print(f"Video 2 FPS: {video2_fps} Hz")

videoObject = cv2.VideoCapture(filename)

if not videoObject.isOpened():
    print(f"‚ùå Error opening video file: {filename}")
    exit()

print(f"{dir=}, {filename=}")

compare_video_fps("First video fps,", "Second video fps")
video2_fps = 5  # Dummy value

# === METADATA ===
fps = videoObject.get(cv2.CAP_PROP_FPS)
fCount = int(videoObject.get(cv2.CAP_PROP_FRAME_COUNT))
w = int(videoObject.get(cv2.CAP_PROP_FRAME_WIDTH))
h = int(videoObject.get(cv2.CAP_PROP_FRAME_HEIGHT))
frame_count = fCount if fCount > 0 else 0

print(f"‚úÖ Loaded: {filename}")
print(f"üéûÔ∏è FPS: {fps:.2f} Hz")
print(f"üìä Total Frames: {frame_count}, Type: {type(frame_count)}")
print(f"üñºÔ∏è Width: {w}, Height: {h}")

# === TIMING ===
idealFrameDelay_ms = 1000 / fps if fps > 0 else 33.33
print(f"‚è±Ô∏è Target Frame Time: {idealFrameDelay_ms:.2f} ms")

# === DISPLAY SETTINGS ===
dispFact = 2
displayRes = (int(w / dispFact), int(h / dispFact))

# === ORB Detector ===
orb = cv2.ORB_create()

# === TRACK PREVIOUS FRAME ===
prev_gray = None
prev_kp = None
prev_des = None

# === MAIN LOOP ===
for i in range(frame_count):
    startTime = time.time()

    success, frame = videoObject.read()
    if not success:
        print(f"‚ùå Failed to read frame {i}")
        break

    grayFrame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    resizedFrame = cv2.resize(grayFrame, displayRes)

    # === PTZ ===
    kp, des = orb.detectAndCompute(grayFrame, None)

    if prev_gray is not None and des is not None and prev_des is not None:
        bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
        matches = bf.match(prev_des, des)

        dx, dy, zooms = [], [], []
        for m in matches:
            pt1 = prev_kp[m.queryIdx].pt
            pt2 = kp[m.trainIdx].pt
            dx.append(pt2[0] - pt1[0])  # pan
            dy.append(pt2[1] - pt1[1])  # tilt

            dist1 = np.linalg.norm(pt1)
            dist2 = np.linalg.norm(pt2)
            if dist1 > 0:
                zooms.append(dist2 / dist1)

        if dx and dy and zooms:
            pan_avg = np.mean(dx)
            tilt_avg = np.mean(dy)
            zoom_avg = np.mean(zooms)
            print(f"üìΩÔ∏è Frame {i}: Pan: {pan_avg:.2f}px | Tilt: {tilt_avg:.2f}px | Zoom: {zoom_avg:.3f}x")

    # === Store frame for next round ===
    prev_gray = grayFrame
    prev_kp = kp
    prev_des = des

    # === Show the grayscale video ===
    cv2.imshow("Black & White Video", resizedFrame)

    # === Timing ===
    endTime = time.time()
    processingTime_ms = 1000 * (endTime - startTime)
    actualWaitTime_ms = max(1, idealFrameDelay_ms - processingTime_ms)

    print(f"proc: {processingTime_ms:.2f} ms, delay: {actualWaitTime_ms:.2f} ms")

    key = cv2.waitKey(int(actualWaitTime_ms))
    if key & 0xFF == ord('q'):
        print("üî¥ Quit by user.")
        break

videoObject.release()
cv2.destroyAllWindows()
